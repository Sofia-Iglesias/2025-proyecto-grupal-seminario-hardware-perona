Este es el codigo terminado del proyecto.

Este código usa:

- Utiliza la librería <Adafruit_NeoPixel.h>
- Utiliza la función theaterChase() importada del repositorio publico de github de adafruit

Este código hace:

- Comprueba por cada ciclo los estados de los sensores del clima (luz, viento y lluvia)
- Espera para que se presione el botón de encendido para mostrar la luz
- Una vez encendido, comprueba si los valores de los sensores coinciden con alguno de los escenarios contemplados
(soleado, soleado + viento, nublado, nublado + viento, lluvia, lluvia + viento).
- Cuando se decide el clima actual, se iluminan los 24 neopixeles de modo que reflejan el estado del cielo, haciendo animaciones acordes 
al viento o la lluvia, o solo quedándose estático si el día no tiene movimiento
- Sigue comprobando el clima, de modo que si este cambia mientras la lámpara está encendida, también se actualiza el patrón de colores
- También incluye un "modo error" en el que la tira hace un efecto arcoíris si el clima no coincide con ningún caso contemplado (no debería de suceder)
- Imprime muchos mensajes para ver en que fase del ciclo está en cada momento. Fueron muy necesarios al momento de corregir errores (costó hacer que funcione)

Código: 

//Documentación: 

//Funciones basicas: https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-use
//Efectos basicos (plantilla): https://github.com/adafruit/Adafruit_NeoPixel/blob/5e742843743af41e1769ae83a25f3d78827f53f7/examples/strandtest/strandtest.ino

#include <Adafruit_NeoPixel.h>
#define NUMPIXELS 24
#define PIN 3
Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);


#define boton_on 4
#define boton_lluvia 2
#define sensor_luz A0
#define sensor_viento A1

int estado = 1;
int estado_P_defecto = 1;
int luz = 0;
int viento = 0;
int lluvia = 1;

int climaActual= 0;

int estado_lluvia = 1;
int estado_lluvia_p_defecto = 1;

uint32_t soleado = strip.Color(255, 255, 0);
uint32_t nublado = strip.Color(128,128,128);
uint32_t lluvioso = strip.Color(0, 49, 83); //Según google, este es el valor RGB del azul de prusia (un azul muy profundo)

void theaterChase(uint32_t color, int wait) { //esta es una función que viene de un repositorio publico de adafruit
  for(int a=0; a<10; a++) {  
    for(int b=0; b<3; b++) { 
      strip.clear();         
      for(int c=b; c<strip.numPixels(); c += 3) {
        strip.setPixelColor(c, color); 
      }
      strip.show(); 
      delay(wait);  
    }
  }
}

void sol_quieto(){
 strip.fill(soleado, 0,  NUMPIXELS);
 strip.show();
 Serial.println("soleado quieto");
}

void sol_movimiento() {
  uint32_t baseColor = strip.Color(255,255,0); //amarillo de "soleado" 
  int largo_onda = 8;   // cantidad de LEDs por ciclo de onda

    
    //calcular que brillo le corresponde a cada LED de la onda según su posición.
    //Esta es la parte aburrida (porque usa matematica). El alto (o en este caso brillo) de una onda
    //se calcula por la fórmula 2π*indice_del_LED*posicion_final/el largo de la onda

    for (int posicion_final = 0; posicion_final < largo_onda; posicion_final++) {
      for (int i = 0; i < NUMPIXELS; i++) {
        // calcular el brillo relativo de cada LED dependiendo de su posición en la onda 
        // (se hace de forma sinusoidal, es decir, que siguen la función del seno)
        float brillo = 2.0 * PI * (i + posicion_final) / largo_onda;
        // brillo entre 50 y 255 para que pueda llegar al brillo máximo pero nunca lleguen a apagarse por completo
        int brillofinal = 50 + (int)(205 * (sin(brillo) * 0.5 + 0.5));

        // aplicar el brillo al color base (en este caso amarillo)
        int r = brillofinal;
        int g = brillofinal;
        int b = 0;

        strip.setPixelColor(i, r, g, b);
      }
      strip.show();
      delay(100);
      Serial.println("sol movimiento");
    }
  
}


void nublado_quieto(){
 strip.fill(nublado, 0,  NUMPIXELS);
 strip.show();
 Serial.println("nublado quieto");
}

void nublado_movimiento(){
 uint32_t baseColor = strip.Color(128,128,128); //gris de "nublado"
  int largo_onda = 8;   // cantidad de LEDs por onda
  int velocidad = 100;      // velocidad de la animación
    
    //calcular que brillo le corresponde a cada LED de la onda según su posición.
    //Esta es la parte aburrida (porque usa matematica). El alto (o en este caso brillo) de una onda
    //se calcula por la fórmula 2π*indice_del_LED*posicion_final/el largo de la onda

    for (int posicion_final = 0; posicion_final < largo_onda; posicion_final++) {
      for (int i = 0; i < NUMPIXELS; i++) {
        // calcular el brillo relativo de cada LED dependiendo de su posición en la onda 
        // (se hace de forma sinusoidal, es decir, que siguen la función del seno)
        float brillo = 2.0 * PI * (i + posicion_final) / largo_onda;
        // brillo entre 50 y 255 para que pueda llegar al brillo máximo pero nunca lleguen a apagarse por completo
        int brillofinal = 50 + (int)(205 * (sin(brillo) * 0.5 + 0.5));

        // aplicar el brillo al color base (en este caso gris)
        int r = brillofinal;
        int g = brillofinal;
        int b = brillofinal;

        strip.setPixelColor(i, r, g, b);
      }
      strip.show();
      delay(100);
      Serial.println("sol movimiento");
    }
}

void lluvia_quieto() {
 strip.fill(lluvioso, 0, NUMPIXELS);
 strip.show();
 Serial.println("lluvioso quieto");
}

void lluvia_movimiento(){
 theaterChase(lluvioso, 100);
 Serial.println("lluvioso movimiento");
}


void setup()
{
  Serial.begin(9600);
  strip.begin();
  strip.setBrightness(255);
  strip.show();
  pinMode(boton_on, INPUT_PULLUP);
  pinMode(boton_lluvia, INPUT_PULLUP);
  pinMode(PIN, OUTPUT);
}

void loop()
{
 
  Serial.println("Entrando a loop");
  
 // encendido:
  estado = digitalRead(boton_on);
  if (estado == 0){
  estado_P_defecto = 0;
  Serial.println("sistema encendido");
  }
  
  luz = analogRead(sensor_luz);
  viento = analogRead(sensor_viento);
  
//mantener boton de lluvia (esto solo se aplica a la simulación, donde
// el sensor de lluvia es reemplazado con un botón para simular su comportamiento)

  lluvia = digitalRead (boton_lluvia);
  if (lluvia == 0) {
  estado_lluvia_p_defecto = 0;
  }else if (lluvia == 1) {
  estado_lluvia_p_defecto = 1;
  }
  
  
Serial.print("Condiciones: luz=");
Serial.println(luz);
Serial.print(" lluvia=");
Serial.println(estado_lluvia_p_defecto);
Serial.print(" viento=");
Serial.println(viento);

  
  //chequear el clima
  if (estado_P_defecto == 0) {
    
    if(luz > 704 && estado_lluvia_p_defecto == 1 && viento < 430){
    //se interpreta como dia soleado sin viento
    climaActual = 1;
    }else if(luz > 704 && estado_lluvia_p_defecto == 1 && viento > 430){
    //se interpreta como un dia soleado con viento
    climaActual = 2;
    }else if(luz < 704 && estado_lluvia_p_defecto == 1 && viento < 430){
    //se interpreta como un dia nublado sin lluvia ni viento
    climaActual = 3;
    }else if(luz < 704 && estado_lluvia_p_defecto == 1 && viento > 430){
    //se interpreta como un dia nublado sin lluvia pero con viento
    climaActual = 4;
    }else if (estado_lluvia_p_defecto == 0 && viento < 430) {
     //se interpreta como día de lluvia sin viento
     climaActual = 5;
    }else if(estado_lluvia_p_defecto == 0 && viento > 430){
    //se interpreta como dia de lluvia con viento
    climaActual = 6;
    } else {
    int i = 0;
    strip.clear();
  	uint32_t color = strip.ColorHSV(i);
    strip.fill(color, 0, NUMPIXELS);
    strip.show();
    i = i + 1500;
    delay(100);
    }
  }
  
  Serial.println(climaActual);
  Serial.println("entrando al switch");
  switch(climaActual){
    case 1: sol_quieto(); break;
    case 2: sol_movimiento(); break;
    case 3: nublado_quieto(); break;
    case 4: nublado_movimiento(); break;
    case 5: lluvia_quieto(); break;
    case 6: lluvia_movimiento(); break;
}

  
  delay(300);
}
